<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>æ™ºèƒ½åƒµå°¸æ·»åŠ å™¨ - å¢å¼ºç‰ˆ</title>
	<script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
	<script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
	<style>
		* { margin: 0; padding: 0; box-sizing: border-box; font-family: Arial, sans-serif; }
		body { background: #0f172a; color: #e2e8f0; padding: 20px; }
		.container { max-width: 1400px; margin: 0 auto; }
		header { background: #1e293b; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
		h1 { color: #60a5fa; margin-bottom: 10px; }
		
		.config-panel {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
			margin: 20px 0;
		}
		
		.panel {
			background: #1e293b;
			padding: 20px;
			border-radius: 8px;
			border: 1px solid #334155;
		}
		
		.panel h3 {
			color: #60a5fa;
			margin-bottom: 15px;
		}
		
		.upload-area {
			border: 2px dashed #3b82f6;
			border-radius: 8px;
			padding: 30px;
			text-align: center;
			background: rgba(30, 64, 175, 0.1);
			cursor: pointer;
			margin: 10px 0;
			transition: all 0.3s;
		}
		
		.upload-area:hover { background: rgba(30, 64, 175, 0.2); }
		
		textarea, input {
			width: 100%;
			padding: 10px;
			margin: 5px 0;
			background: #0f172a;
			border: 1px solid #334155;
			border-radius: 4px;
			color: #e2e8f0;
			font-family: 'Consolas', monospace;
		}
		
		textarea { height: 120px; }
		
		.info-text {
			color: #94a3b8;
			font-size: 12px;
			margin-top: 5px;
		}
		
		button {
			background: #3b82f6;
			color: white;
			border: none;
			padding: 12px 24px;
			border-radius: 6px;
			cursor: pointer;
			font-weight: bold;
			margin: 5px;
			transition: all 0.3s;
		}
		
		button:hover { background: #2563eb; transform: translateY(-2px); }
		button:disabled { background: #64748b; cursor: not-allowed; }
		
		.log {
			background: #1e293b;
			padding: 15px;
			border-radius: 8px;
			margin-top: 20px;
			font-family: 'Consolas', monospace;
			font-size: 13px;
			white-space: pre-wrap;
			max-height: 500px;
			overflow-y: auto;
		}
		
		.success { color: #4ade80; }
		.warning { color: #fbbf24; }
		.error { color: #f87171; }
		.info { color: #60a5fa; }
		.new-wave { color: #a855f7; }
		
		.wave-preview {
			margin-top: 10px;
			padding: 10px;
			background: #0f172a;
			border-radius: 4px;
			border: 1px dashed #334155;
		}
		
		.wave-item {
			display: inline-block;
			background: rgba(59, 130, 246, 0.2);
			padding: 4px 8px;
			margin: 2px;
			border-radius: 4px;
			font-size: 12px;
		}
	</style>
</head>
<body>
	<div class="container">
		<header>
			<h1>ğŸ§¬ æ™ºèƒ½åƒµå°¸æ·»åŠ å™¨ - å¢å¼ºç‰ˆ</h1>
			<p>æ”¯æŒæ‰¹é‡æ·»åŠ åƒµå°¸ã€æ™ºèƒ½æ³¢æ¬¡åˆ¤æ–­ã€è‡ªå®šä¹‰åƒµå°¸åç§°</p>
		</header>
		
		<div class="config-panel">
			<div class="panel">
				<h3>ğŸ“ æ–‡ä»¶ä¸Šä¼ </h3>
				<div class="upload-area" onclick="document.getElementById('fileInput').click()">
					ç‚¹å‡»é€‰æ‹©ZIPæ–‡ä»¶ï¼Œæˆ–æ‹–æ”¾æ–‡ä»¶åˆ°è¿™é‡Œ
					<div class="info-text">æ”¯æŒåŒ…å«å¤šä¸ªJSONæ–‡ä»¶çš„ZIPå‹ç¼©åŒ…</div>
				</div>
				<input type="file" id="fileInput" accept=".zip" style="display: none;">
				
				<div id="fileInfo" style="margin-top: 10px;"></div>
			</div>
			
			<div class="panel">
				<h3>âš™ï¸ é…ç½®é€‰é¡¹</h3>
				
				<label>è¦æ·»åŠ çš„åƒµå°¸åç§°ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰:</label>
				<textarea id="zombieNames" placeholder="è¾“å…¥åƒµå°¸RTIDï¼Œæ¯è¡Œä¸€ä¸ª
ä¾‹å¦‚ï¼š
respro@ZombieTypes
zombie_king@ZombieTypes
gargantuar@ZombieTypes"></textarea>
				<div class="info-text">æ ¼å¼ï¼šåƒµå°¸ç±»å‹@ZombieTypes</div>
				
				<label>æ³¢æ•°ï¼ˆæ¯è¡Œä¸€ä¸ªï¼Œç•™ç©ºåˆ™æ™ºèƒ½åˆ¤æ–­ï¼‰:</label>
				<textarea id="waveNumbers" placeholder="è¾“å…¥æ³¢æ•°ï¼Œæ¯è¡Œä¸€ä¸ª
ä¾‹å¦‚ï¼š
1
2
3
ç•™ç©ºåˆ™è‡ªåŠ¨åˆ¤æ–­"></textarea>
				<div class="info-text">ç•™ç©ºåˆ™è‡ªåŠ¨æ£€æµ‹å¹¶æ·»åŠ åˆ°åˆé€‚çš„æ³¢æ¬¡</div>
				
				<div id="wavePreview" class="wave-preview"></div>
			</div>
		</div>
		
		<div>
			<button onclick="processZip()">å¼€å§‹å¤„ç†</button>
			<button onclick="downloadResult()" id="downloadBtn" disabled>ä¸‹è½½å¤„ç†ç»“æœ</button>
			<button onclick="resetAll()">é‡ç½®</button>
		</div>
		
		<div class="log" id="log">ç­‰å¾…é…ç½®...</div>
	</div>

	<script>
		let originalZip = null;
		let processedZip = null;
		let logElement = document.getElementById('log');
		let fileInfoElement = document.getElementById('fileInfo');
		let wavePreviewElement = document.getElementById('wavePreview');
		
		// è§£æåƒµå°¸åç§°
		function parseZombieNames() {
			const input = document.getElementById('zombieNames').value.trim();
			if (!input) {
				addLog('âš ï¸ è¯·è¾“å…¥è¦æ·»åŠ çš„åƒµå°¸åç§°', 'warning');
				return null;
			}
			
			const lines = input.split('\n')
				.map(line => line.trim())
				.filter(line => line.length > 0);
			
			const zombies = lines.map(line => {
				if (!line.includes('@ZombieTypes')) {
					return `${line}@ZombieTypes`;
				}
				return line;
			});
			
			addLog(`ğŸ“‹ è§£æåˆ° ${zombies.length} ä¸ªåƒµå°¸: ${zombies.join(', ')}`, 'info');
			return zombies;
		}
		
		// è§£ææ³¢æ•°
		function parseWaveNumbers() {
			const input = document.getElementById('waveNumbers').value.trim();
			if (!input) {
				addLog('ğŸ” æœªæŒ‡å®šæ³¢æ•°ï¼Œå°†è‡ªåŠ¨åˆ¤æ–­', 'info');
				return null;
			}
			
			const lines = input.split('\n')
				.map(line => line.trim())
				.filter(line => line.length > 0)
				.map(line => parseInt(line));
			
			if (lines.some(isNaN)) {
				addLog('âŒ æ³¢æ•°å¿…é¡»æ˜¯æ•°å­—', 'error');
				return null;
			}
			
			addLog(`ğŸŒŠ æŒ‡å®šæ³¢æ•°: ${lines.join(', ')}`, 'info');
			return lines;
		}
		
		document.getElementById('fileInput').addEventListener('change', async (e) => {
			const file = e.target.files[0];
			if (!file) return;
			
			if (!file.name.toLowerCase().endsWith('.zip')) {
				addLog('âŒ è¯·é€‰æ‹©ZIPæ–‡ä»¶', 'error');
				return;
			}
			
			fileInfoElement.innerHTML = `<span class="info">ğŸ“¦ å·²é€‰æ‹©: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)</span>`;
			addLog(`ğŸ“¦ å·²é€‰æ‹©æ–‡ä»¶: ${file.name}`, 'info');
			originalZip = file;
		});
		
		async function processZip() {
			if (!originalZip) {
				addLog('âŒ è¯·å…ˆé€‰æ‹©ZIPæ–‡ä»¶', 'error');
				return;
			}
			
			const zombies = parseZombieNames();
			if (!zombies) return;
			
			const waveNumbers = parseWaveNumbers();
			
			addLog('ğŸš€ å¼€å§‹å¤„ç†ZIPæ–‡ä»¶...', 'info');
			
			try {
				const zip = await JSZip.loadAsync(originalZip);
				const newZip = new JSZip();
				let processedCount = 0;
				let modifiedCount = 0;
				let stats = {
					escalationMode: 0,
					waveMode: 0,
					newWaveCreated: 0,
					zombiesAdded: 0,
					wavesModified: 0
				};
				
				for (const [filename, file] of Object.entries(zip.files)) {
					if (!file.dir && filename.toLowerCase().endsWith('.json')) {
						addLog(`\nğŸ“„ å¤„ç†æ–‡ä»¶: ${filename}`, 'info');
						processedCount++;
						
						try {
							const content = await file.async('text');
							const result = processJsonFile(content, filename, zombies, waveNumbers, stats);
							
							if (result.modified) {
								newZip.file(filename, result.content);
								modifiedCount++;
							} else {
								newZip.file(filename, content);
							}
						} catch (err) {
							addLog(`âš ï¸ å¤„ç†å¤±è´¥: ${err.message}`, 'warning');
							newZip.file(filename, await file.async('string'));
						}
					} else if (!file.dir) {
						newZip.file(filename, await file.async('arraybuffer'));
					}
				}
				
				processedZip = await newZip.generateAsync({type: 'blob'});
				
				// æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
				addLog(`\nğŸ“Š ======== å¤„ç†ç»Ÿè®¡ ========`, 'info');
				addLog(`   æ€»å¤„ç†æ–‡ä»¶æ•°: ${processedCount}`, 'info');
				addLog(`   å·²ä¿®æ”¹æ–‡ä»¶æ•°: ${modifiedCount}`, 'success');
				addLog(`\nğŸ“‹ å¤„ç†è¯¦æƒ…:`, 'info');
				addLog(`   â€¢ éšæœºå‡ºæ€ªæ¨¡å¼: ${stats.escalationMode} ä¸ª`, 'info');
				addLog(`   â€¢ å¸¸è§„æ³¢æ¬¡æ¨¡å¼: ${stats.waveMode} ä¸ª`, 'info');
				addLog(`   â€¢ æ–°å»ºæ³¢æ¬¡: ${stats.newWaveCreated} ä¸ª`, 'new-wave');
				addLog(`   â€¢ æ·»åŠ åƒµå°¸æ•°: ${stats.zombiesAdded} ä¸ª`, 'success');
				addLog(`   â€¢ ä¿®æ”¹æ³¢æ¬¡æ•°: ${stats.wavesModified} ä¸ª`, 'success');
				
				addLog('\nâœ… å¤„ç†å®Œæˆï¼', 'success');
				document.getElementById('downloadBtn').disabled = false;
				
			} catch (err) {
				addLog(`âŒ å¤„ç†å¤±è´¥: ${err.message}`, 'error');
			}
		}
		
		function processJsonFile(content, filename, zombies, waveNumbers, stats) {
			let json;
			
			try {
				json = JSON.parse(content);
			} catch (err) {
				try {
					const fixed = content.replace(/([{,]\s*)(\w+)(\s*:)/g, '$1"$2"$3');
					json = JSON.parse(fixed);
					addLog('  ğŸ”§ å·²ä¿®å¤JSONæ ¼å¼', 'warning');
				} catch (err2) {
					addLog(`  âŒ JSONè§£æå¤±è´¥: ${err2.message}`, 'error');
					return { modified: false, content: null };
				}
			}
			
			if (!json.objects || !Array.isArray(json.objects)) {
				addLog('  âš ï¸ æ— objectsæ•°ç»„ï¼Œè·³è¿‡', 'warning');
				return { modified: false, content: null };
			}
			
			// æŸ¥æ‰¾å…³å¡æ¨¡å¼
			let hasEscalation = false;
			let escalationModule = null;
			let waveManager = null;
			let totalWaves = 0;
			
			for (let obj of json.objects) {
				if (obj.objclass === 'LevelEscalationModuleProperties' && obj.objdata) {
					hasEscalation = true;
					escalationModule = obj;
				}
				if (obj.objclass === 'WaveManagerProperties' && obj.objdata && obj.objdata.Waves) {
					waveManager = obj;
					totalWaves = obj.objdata.Waves ? obj.objdata.Waves.length : 0;
				}
			}
			
			addLog(`  ğŸ“ˆ æ€»æ³¢æ•°: ${totalWaves}`, 'info');
			
			let modified = false;
			
			// æ¨¡å¼1: éšæœºå‡ºæ€ªæ¨¡å¼
			if (hasEscalation && escalationModule) {
				const zombiePool = escalationModule.objdata.ZombiePool;
				if (zombiePool && Array.isArray(zombiePool)) {
					let addedCount = 0;
					for (const zombie of zombies) {
						const zombieRTID = `RTID(${zombie})`;
						if (!zombiePool.includes(zombieRTID)) {
							zombiePool.push(zombieRTID);
							addedCount++;
							stats.zombiesAdded++;
						}
					}
					if (addedCount > 0) {
						addLog(`  âœ… å·²åœ¨ZombiePoolä¸­æ·»åŠ  ${addedCount} ä¸ªåƒµå°¸`, 'success');
						modified = true;
						stats.escalationMode++;
					} else {
						addLog('  â­ï¸ ZombiePoolå·²åŒ…å«æ‰€æœ‰æŒ‡å®šåƒµå°¸', 'warning');
					}
				}
			}
			
			// æ¨¡å¼2: å¸¸è§„æ³¢æ¬¡æ¨¡å¼
			if (waveManager && waveManager.objdata && waveManager.objdata.Waves) {
				const waves = waveManager.objdata.Waves;
				
				// ç¡®å®šè¦å¤„ç†çš„æ³¢æ¬¡
				let wavesToProcess = [];
				if (waveNumbers) {
					// ä½¿ç”¨æŒ‡å®šçš„æ³¢æ•°
					wavesToProcess = waveNumbers
						.map(num => num - 1) // è½¬æ¢ä¸º0-basedç´¢å¼•
						.filter(index => index >= 0 && index < waves.length);
				} else {
					// è‡ªåŠ¨åˆ¤æ–­ï¼šå°è¯•å‰3æ³¢
					wavesToProcess = [0, 1, 2].filter(index => index < waves.length);
				}
				
				if (wavesToProcess.length === 0) {
					addLog('  âš ï¸ æ— æœ‰æ•ˆæ³¢æ¬¡å¯å¤„ç†', 'warning');
				} else {
					addLog(`  ğŸŒŠ å¤„ç†æ³¢æ¬¡: ${wavesToProcess.map(i => i+1).join(', ')}`, 'info');
					
					for (const waveIndex of wavesToProcess) {
						const waveItems = waves[waveIndex];
						if (!waveItems || waveItems.length === 0) continue;
						
						// æŸ¥æ‰¾è¿™ä¸ªæ³¢æ¬¡ä¸­çš„åƒµå°¸æ³¢
						for (let waveItem of waveItems) {
							const cleanName = waveItem.replace(/^RTID\(|\)$/g, '').split('@')[0];
							
							for (let obj of json.objects) {
								if (obj.aliases && obj.aliases.includes(cleanName) && 
									obj.objdata && obj.objdata.Zombies &&
									(obj.objclass === 'SpawnZombiesJitteredWaveActionProps' || 
									 obj.objclass === 'SpawnZombiesWaveActionProps' ||
									 obj.objclass === 'SpawnZombiesRandomWaveActionProps')) {
									
									let addedCount = 0;
									for (const zombie of zombies) {
										const hasZombie = obj.objdata.Zombies.some(z => 
											z.Type && z.Type.includes(zombie.split('@')[0])
										);
										
										if (!hasZombie) {
											obj.objdata.Zombies.push({
												"Type": `RTID(${zombie})`
											});
											addedCount++;
											stats.zombiesAdded++;
										}
									}
									
									if (addedCount > 0) {
										addLog(`  âœ… æ³¢æ¬¡ ${waveIndex+1} (${cleanName}) æ·»åŠ  ${addedCount} ä¸ªåƒµå°¸`, 'success');
										modified = true;
										stats.waveMode++;
										stats.wavesModified++;
									}
									break;
								}
							}
						}
					}
					
					// å¦‚æœæŒ‡å®šæ³¢æ•°ä½†æœªæ‰¾åˆ°åƒµå°¸æ³¢ï¼Œåˆ›å»ºæ–°æ³¢æ¬¡
					if (waveNumbers && !modified) {
						addLog('  ğŸ†• æœªæ‰¾åˆ°æŒ‡å®šæ³¢æ¬¡çš„åƒµå°¸æ³¢ï¼Œå°è¯•åˆ›å»ºæ–°æ³¢æ¬¡...', 'warning');
						
						for (const waveIndex of wavesToProcess) {
							if (waveIndex >= waves.length) continue;
							
							const newWaveName = `AutoWave${Date.now()}${waveIndex}`;
							const newWaveRTID = `RTID(${newWaveName}@CurrentLevel)`;
							
							// åˆ›å»ºæ–°æ³¢æ¬¡å¯¹è±¡
							const newWaveObject = {
								"aliases": [newWaveName],
								"objclass": "SpawnZombiesJitteredWaveActionProps",
								"objdata": {
									"AdditionalPlantfood": 0,
									"Zombies": zombies.map(zombie => ({
										"Type": `RTID(${zombie})`
									}))
								}
							};
							
							// æ·»åŠ åˆ°objectsæ•°ç»„
							json.objects.push(newWaveObject);
							
							// æ·»åŠ åˆ°æŒ‡å®šæ³¢æ¬¡
							if (!waves[waveIndex]) {
								waves[waveIndex] = [newWaveRTID];
							} else {
								waves[waveIndex].push(newWaveRTID);
							}
							
							addLog(`  âœ… åœ¨æ³¢æ¬¡ ${waveIndex+1} åˆ›å»ºæ–°æ³¢æ¬¡ ${newWaveName}`, 'success');
							modified = true;
							stats.newWaveCreated++;
							stats.wavesModified++;
							stats.zombiesAdded += zombies.length;
						}
					}
				}
			}
			
			if (!modified) {
				addLog('  â­ï¸ æœªè¿›è¡Œä¿®æ”¹', 'info');
				return { modified: false, content: null };
			}
			
			return { 
				modified: true, 
				content: JSON.stringify(json, null, 2) 
			};
		}
		
		async function downloadResult() {
			if (!processedZip) {
				addLog('âŒ æ²¡æœ‰å¯ä¸‹è½½çš„æ–‡ä»¶', 'error');
				return;
			}
			
			const fileName = originalZip.name.replace(/\.zip$/i, '_modified.zip');
			saveAs(processedZip, fileName);
			addLog(`ğŸ“¥ å·²ç”Ÿæˆæ–‡ä»¶: ${fileName}`, 'success');
		}
		
		function resetAll() {
			document.getElementById('zombieNames').value = 'respro@ZombieTypes';
			document.getElementById('waveNumbers').value = '';
			originalZip = null;
			processedZip = null;
			logElement.innerHTML = 'ç­‰å¾…é…ç½®...';
			fileInfoElement.innerHTML = '';
			document.getElementById('downloadBtn').disabled = true;
			addLog('ğŸ”„ å·²é‡ç½®æ‰€æœ‰é…ç½®', 'info');
		}
		
		function addLog(message, type = 'info') {
			const timestamp = new Date().toLocaleTimeString('zh-CN', { hour12: false });
			const logLine = `[${timestamp}] <span class="${type}">${message}</span>\n`;
			logElement.innerHTML += logLine;
			logElement.scrollTop = logElement.scrollHeight;
		}
		
		// æ‹–æ”¾åŠŸèƒ½
		const dropArea = document.querySelector('.upload-area');
		['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
			dropArea.addEventListener(eventName, preventDefaults, false);
		});
		
		function preventDefaults(e) {
			e.preventDefault();
			e.stopPropagation();
		}
		
		['dragenter', 'dragover'].forEach(eventName => {
			dropArea.addEventListener(eventName, () => {
				dropArea.style.background = 'rgba(59, 130, 246, 0.3)';
			}, false);
		});
		
		['dragleave', 'drop'].forEach(eventName => {
			dropArea.addEventListener(eventName, () => {
				dropArea.style.background = 'rgba(30, 64, 175, 0.1)';
			}, false);
		});
		
		dropArea.addEventListener('drop', (e) => {
			const dt = e.dataTransfer;
			const files = dt.files;
			if (files.length > 0) {
				const file = files[0];
				if (file.name.toLowerCase().endsWith('.zip')) {
					addLog(`ğŸ“¦ å·²æ‹–æ”¾æ–‡ä»¶: ${file.name}`, 'info');
					originalZip = file;
					fileInfoElement.innerHTML = `<span class="info">ğŸ“¦ å·²é€‰æ‹©: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)</span>`;
				} else {
					addLog('âŒ è¯·æ‹–æ”¾ZIPæ–‡ä»¶', 'error');
				}
			}
		});
		
		// åˆå§‹åŒ–é»˜è®¤å€¼
		document.getElementById('zombieNames').value = 'respro@ZombieTypes';
	</script>
</body>
</html>